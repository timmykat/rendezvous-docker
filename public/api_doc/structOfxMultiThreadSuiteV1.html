<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>OFX: OfxMultiThreadSuiteV1 Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OFX
   &#160;<span id="projectnumber">1.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structOfxMultiThreadSuiteV1.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structOfxMultiThreadSuiteV1-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OfxMultiThreadSuiteV1 Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>OFX suite that provides simple SMP style multi-processing.  
 <a href="structOfxMultiThreadSuiteV1.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ofxMultiThread_8h_source.html">ofxMultiThread.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aeb76e0fddb366f5ef3be7026495853d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ofxCore_8h.html#a458fea218d3024a9a8c28d06301ad920">OfxStatus</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOfxMultiThreadSuiteV1.html#aeb76e0fddb366f5ef3be7026495853d1">multiThread</a> )(<a class="el" href="ofxMultiThread_8h.html#a4f8d5ea49eb1d61121f91b299eea1689">OfxThreadFunctionV1</a> func, unsigned int nThreads, void *customArg)</td></tr>
<tr class="memdesc:aeb76e0fddb366f5ef3be7026495853d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to spawn SMP threads.  <a href="#aeb76e0fddb366f5ef3be7026495853d1">More...</a><br/></td></tr>
<tr class="separator:aeb76e0fddb366f5ef3be7026495853d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8014e9d27cf180243c4cbc3cb7414dac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ofxCore_8h.html#a458fea218d3024a9a8c28d06301ad920">OfxStatus</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOfxMultiThreadSuiteV1.html#a8014e9d27cf180243c4cbc3cb7414dac">multiThreadNumCPUs</a> )(unsigned int *nCPUs)</td></tr>
<tr class="memdesc:a8014e9d27cf180243c4cbc3cb7414dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which indicates the number of CPUs available for SMP processing.  <a href="#a8014e9d27cf180243c4cbc3cb7414dac">More...</a><br/></td></tr>
<tr class="separator:a8014e9d27cf180243c4cbc3cb7414dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae184d5f36757f45eaa931aadab8316f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ofxCore_8h.html#a458fea218d3024a9a8c28d06301ad920">OfxStatus</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOfxMultiThreadSuiteV1.html#ae184d5f36757f45eaa931aadab8316f2">multiThreadIndex</a> )(unsigned int *threadIndex)</td></tr>
<tr class="memdesc:ae184d5f36757f45eaa931aadab8316f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which indicates the index of the current thread.  <a href="#ae184d5f36757f45eaa931aadab8316f2">More...</a><br/></td></tr>
<tr class="separator:ae184d5f36757f45eaa931aadab8316f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91ec671601d0855303858729075280d"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOfxMultiThreadSuiteV1.html#af91ec671601d0855303858729075280d">multiThreadIsSpawnedThread</a> )(void)</td></tr>
<tr class="memdesc:af91ec671601d0855303858729075280d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to enquire if the calling thread was spawned by multiThread.  <a href="#af91ec671601d0855303858729075280d">More...</a><br/></td></tr>
<tr class="separator:af91ec671601d0855303858729075280d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454d0e2dd83129cc02332881ace89e6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ofxCore_8h.html#a458fea218d3024a9a8c28d06301ad920">OfxStatus</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOfxMultiThreadSuiteV1.html#a454d0e2dd83129cc02332881ace89e6b">mutexCreate</a> )(const <a class="el" href="ofxMultiThread_8h.html#acd4857666608472f721a8504131a9046">OfxMutexHandle</a> *mutex, int lockCount)</td></tr>
<tr class="memdesc:a454d0e2dd83129cc02332881ace89e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mutex.  <a href="#a454d0e2dd83129cc02332881ace89e6b">More...</a><br/></td></tr>
<tr class="separator:a454d0e2dd83129cc02332881ace89e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6024179e6c3a6e51e5cead07e766946"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ofxCore_8h.html#a458fea218d3024a9a8c28d06301ad920">OfxStatus</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOfxMultiThreadSuiteV1.html#ac6024179e6c3a6e51e5cead07e766946">mutexDestroy</a> )(const <a class="el" href="ofxMultiThread_8h.html#acd4857666608472f721a8504131a9046">OfxMutexHandle</a> mutex)</td></tr>
<tr class="memdesc:ac6024179e6c3a6e51e5cead07e766946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a mutex.  <a href="#ac6024179e6c3a6e51e5cead07e766946">More...</a><br/></td></tr>
<tr class="separator:ac6024179e6c3a6e51e5cead07e766946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8209828732dc61fee019b8d57edb91a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ofxCore_8h.html#a458fea218d3024a9a8c28d06301ad920">OfxStatus</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOfxMultiThreadSuiteV1.html#af8209828732dc61fee019b8d57edb91a">mutexLock</a> )(const <a class="el" href="ofxMultiThread_8h.html#acd4857666608472f721a8504131a9046">OfxMutexHandle</a> mutex)</td></tr>
<tr class="memdesc:af8209828732dc61fee019b8d57edb91a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking lock on the mutex.  <a href="#af8209828732dc61fee019b8d57edb91a">More...</a><br/></td></tr>
<tr class="separator:af8209828732dc61fee019b8d57edb91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cff75023156ae9265f4893bf21b0408"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ofxCore_8h.html#a458fea218d3024a9a8c28d06301ad920">OfxStatus</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOfxMultiThreadSuiteV1.html#a2cff75023156ae9265f4893bf21b0408">mutexUnLock</a> )(const <a class="el" href="ofxMultiThread_8h.html#acd4857666608472f721a8504131a9046">OfxMutexHandle</a> mutex)</td></tr>
<tr class="memdesc:a2cff75023156ae9265f4893bf21b0408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the mutex.  <a href="#a2cff75023156ae9265f4893bf21b0408">More...</a><br/></td></tr>
<tr class="separator:a2cff75023156ae9265f4893bf21b0408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058855a7c066259efc0e218d3cc6e6b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ofxCore_8h.html#a458fea218d3024a9a8c28d06301ad920">OfxStatus</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOfxMultiThreadSuiteV1.html#a058855a7c066259efc0e218d3cc6e6b8">mutexTryLock</a> )(const <a class="el" href="ofxMultiThread_8h.html#acd4857666608472f721a8504131a9046">OfxMutexHandle</a> mutex)</td></tr>
<tr class="memdesc:a058855a7c066259efc0e218d3cc6e6b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non blocking attempt to lock the mutex.  <a href="#a058855a7c066259efc0e218d3cc6e6b8">More...</a><br/></td></tr>
<tr class="separator:a058855a7c066259efc0e218d3cc6e6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>OFX suite that provides simple SMP style multi-processing. </p>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aeb76e0fddb366f5ef3be7026495853d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ofxCore_8h.html#a458fea218d3024a9a8c28d06301ad920">OfxStatus</a>(* OfxMultiThreadSuiteV1::multiThread)(<a class="el" href="ofxMultiThread_8h.html#a4f8d5ea49eb1d61121f91b299eea1689">OfxThreadFunctionV1</a> func, unsigned int nThreads, void *customArg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to spawn SMP threads. </p>
<ul>
<li>func The function to call in each thread. </li>
<li>nThreads The number of threads to launch </li>
<li>customArg The paramter to pass to customArg of func in each thread.</li>
</ul>
<p>This function will spawn nThreads separate threads of computation (typically one per CPU) to allow something to perform symmetric multi processing. Each thread will call 'func' passing in the index of the thread and the number of threads actually launched.</p>
<p>multiThread will not return until all the spawned threads have returned. It is up to the host how it waits for all the threads to return (busy wait, blocking, whatever).</p>
<p><em>nThreads</em> can be more than the value returned by multiThreadNumCPUs, however the threads will be limitted to the number of CPUs returned by multiThreadNumCPUs.</p>
<p>This function cannot be called recursively.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><a class="el" href="group__StatusCodesGeneral.html#ga2ae346dcc886e9144d1ad32522fbad0a" title="Status code indicating all was fine. ">kOfxStatOK</a>, the function func has executed and returned sucessfully</li>
<li><a class="el" href="group__StatusCodesGeneral.html#ga0a044b3e270fab013e0845b8e662e752" title="Status error code for a failed operation. ">kOfxStatFailed</a>, the threading function failed to launch</li>
<li><a class="el" href="group__StatusCodesGeneral.html#gac559d9a8df408ac99bd36bff27c29262" title="Status error code for an operation attempting to create something that exists. ">kOfxStatErrExists</a>, failed in an attempt to call multiThread recursively, </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae184d5f36757f45eaa931aadab8316f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ofxCore_8h.html#a458fea218d3024a9a8c28d06301ad920">OfxStatus</a>(* OfxMultiThreadSuiteV1::multiThreadIndex)(unsigned int *threadIndex)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which indicates the index of the current thread. </p>
<ul>
<li>threadIndex pointer to an integer where the result is returned</li>
</ul>
<p>This function returns the thread index, which is the same as the <em>threadIndex</em> argument passed to the <a class="el" href="ofxMultiThread_8h.html#a4f8d5ea49eb1d61121f91b299eea1689" title="The function type to passed to the multi threading routines. ">OfxThreadFunctionV1</a>.</p>
<p>If there are no threads currently spawned, then this function will set threadIndex to 0</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><a class="el" href="group__StatusCodesGeneral.html#ga2ae346dcc886e9144d1ad32522fbad0a" title="Status code indicating all was fine. ">kOfxStatOK</a>, all was OK and the maximum number of threads is in nThreads.</li>
<li><a class="el" href="group__StatusCodesGeneral.html#ga0a044b3e270fab013e0845b8e662e752" title="Status error code for a failed operation. ">kOfxStatFailed</a>, the function failed to return an index </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af91ec671601d0855303858729075280d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* OfxMultiThreadSuiteV1::multiThreadIsSpawnedThread)(void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to enquire if the calling thread was spawned by multiThread. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if the thread is not one spawned by multiThread</li>
<li>1 if the thread was spawned by multiThread </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a8014e9d27cf180243c4cbc3cb7414dac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ofxCore_8h.html#a458fea218d3024a9a8c28d06301ad920">OfxStatus</a>(* OfxMultiThreadSuiteV1::multiThreadNumCPUs)(unsigned int *nCPUs)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which indicates the number of CPUs available for SMP processing. </p>
<ul>
<li>nCPUs pointer to an integer where the result is returned</li>
</ul>
<p>This value may be less than the actual number of CPUs on a machine, as the host may reserve other CPUs for itself.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><a class="el" href="group__StatusCodesGeneral.html#ga2ae346dcc886e9144d1ad32522fbad0a" title="Status code indicating all was fine. ">kOfxStatOK</a>, all was OK and the maximum number of threads is in nThreads.</li>
<li><a class="el" href="group__StatusCodesGeneral.html#ga0a044b3e270fab013e0845b8e662e752" title="Status error code for a failed operation. ">kOfxStatFailed</a>, the function failed to get the number of CPUs </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a454d0e2dd83129cc02332881ace89e6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ofxCore_8h.html#a458fea218d3024a9a8c28d06301ad920">OfxStatus</a>(* OfxMultiThreadSuiteV1::mutexCreate)(const <a class="el" href="ofxMultiThread_8h.html#acd4857666608472f721a8504131a9046">OfxMutexHandle</a> *mutex, int lockCount)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a mutex. </p>
<ul>
<li>mutex - where the new handle is returned </li>
<li>count - initial lock count on the mutex. This can be negative.</li>
</ul>
<p>Creates a new mutex with lockCount locks on the mutex intially set.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>kOfxStatOK - mutex is now valid and ready to go </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ac6024179e6c3a6e51e5cead07e766946"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ofxCore_8h.html#a458fea218d3024a9a8c28d06301ad920">OfxStatus</a>(* OfxMultiThreadSuiteV1::mutexDestroy)(const <a class="el" href="ofxMultiThread_8h.html#acd4857666608472f721a8504131a9046">OfxMutexHandle</a> mutex)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a mutex. </p>
<p>Destroys a mutex intially created by mutexCreate.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>kOfxStatOK - if it destroyed the mutex</li>
<li>kOfxStatErrBadHandle - if the handle was bad </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af8209828732dc61fee019b8d57edb91a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ofxCore_8h.html#a458fea218d3024a9a8c28d06301ad920">OfxStatus</a>(* OfxMultiThreadSuiteV1::mutexLock)(const <a class="el" href="ofxMultiThread_8h.html#acd4857666608472f721a8504131a9046">OfxMutexHandle</a> mutex)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocking lock on the mutex. </p>
<p>This trys to lock a mutex and blocks the thread it is in until the lock suceeds.</p>
<p>A sucessful lock causes the mutex's lock count to be increased by one and to block any other calls to lock the mutex until it is unlocked.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>kOfxStatOK - if it got the lock</li>
<li>kOfxStatErrBadHandle - if the handle was bad </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a058855a7c066259efc0e218d3cc6e6b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ofxCore_8h.html#a458fea218d3024a9a8c28d06301ad920">OfxStatus</a>(* OfxMultiThreadSuiteV1::mutexTryLock)(const <a class="el" href="ofxMultiThread_8h.html#acd4857666608472f721a8504131a9046">OfxMutexHandle</a> mutex)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non blocking attempt to lock the mutex. </p>
<p>This attempts to lock a mutex, if it cannot, it returns and says so, rather than blocking.</p>
<p>A sucessful lock causes the mutex's lock count to be increased by one, if the lock did not suceed, the call returns immediately and the lock count remains unchanged.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>kOfxStatOK - if it got the lock</li>
<li>kOfxStatFailed - if it did not get the lock</li>
<li>kOfxStatErrBadHandle - if the handle was bad </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a2cff75023156ae9265f4893bf21b0408"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ofxCore_8h.html#a458fea218d3024a9a8c28d06301ad920">OfxStatus</a>(* OfxMultiThreadSuiteV1::mutexUnLock)(const <a class="el" href="ofxMultiThread_8h.html#acd4857666608472f721a8504131a9046">OfxMutexHandle</a> mutex)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock the mutex. </p>
<p>This unlocks a mutex. Unlocking a mutex decreases its lock count by one.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>kOfxStatOK if it released the lock</li>
<li>kOfxStatErrBadHandle if the handle was bad </li>
</ul>
</dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="ofxMultiThread_8h_source.html">ofxMultiThread.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr width="75%" size="2" noshade="">
<small>
Copyright 2003-2012 The Open Effects Association  Ltd. All rights reserved.<br>
Copying and redistribution with or without
modification, is permitted provided that the following conditions are met:
<ol>
    <li> Redistributions of the document must retain the above copyright notice
      and this list of conditions.</li>
    <li>  Neither the name of The Open Effects Association Ltd nor names of its 
      contributors may be used to
      endorse or promote products derived from this software without specific
      prior written permission.</li>
</ol>
Automatic documentation generated by <a href="http://www.doxygen.org">Doxygen</a>.<br>
</small>
